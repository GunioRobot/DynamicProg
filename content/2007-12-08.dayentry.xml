<?xml version="1.0" encoding="utf-8"?>
<DayEntry xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:newtelligence-com:dasblog:runtime:data">
  <Date>2007-12-07T17:00:00-07:00</Date>
  <Entries>
    <Entry>
      <Content>&lt;p&gt;I just came across this: &lt;a target="_blank" href="http://labs.live.com/volta/"&gt;http://labs.live.com/volta/.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;I haven't downloaded or anything but my first impression is that this try to be some kind of AIR. It's not exactly the same, but the idea, according with my limited understading, is that you program an application using any .NET language and them you can compile the application targeting different architectures. The client side always run on a JScript interpreter, most of the time that will be a browser.&lt;/p&gt;&lt;p&gt;I tried some of the examples and the load time seems to be a little too much for my taste. Upon looking at the Net tab in Firebug, a simple Ajax dictionary download 2.67 Mg of code mostly JavaScript files that map into .net classes, but that is not the worst part, the really bad thing is that it do this making &lt;strong&gt;175 individual httpRequest!!!!&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;To be fair this is just a Technology Preview and I'm sure that they may work on some of this issues. This came out just two days ago, so I encourage you all to download it and give a try to learn more, I know I will do that.&lt;/p&gt;</Content>
      <Created>2007-12-07T22:33:11-07:00</Created>
      <Modified>2008-12-14T22:37:49.8073877-07:00</Modified>
      <EntryId>13</EntryId>
      <Description />
      <Title>Microsoft Volta - AIR.NET?</Title>
      <Categories>Frameworks;General</Categories>
      <Author>hgarcia</Author>
      <IsPublic>true</IsPublic>
      <Syndicated>true</Syndicated>
      <ShowOnFrontPage>true</ShowOnFrontPage>
      <AllowComments>true</AllowComments>
      <Attachments />
      <Crossposts />
      <Latitude xsi:nil="true" />
      <Longitude xsi:nil="true" />
    </Entry>
    <Entry>
      <Content>&lt;p&gt;In this second part we look at the factory methods to handle the different request and the formatters classes.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h3&gt;The Factory.&lt;/h3&gt;&lt;p&gt;The use of a factory allow us to easily extend this framework with minimun coding.&lt;/p&gt;&lt;pre lang="csharp"&gt;using System;&lt;br&gt;using System.Web;&lt;br&gt;&lt;br&gt;namespace LaTrompa.Services&lt;br&gt;{&lt;br&gt;    public class ServiceHandlerFactory &lt;br&gt;    {&lt;br&gt;        /// &amp;lt;summary&amp;gt;&lt;br&gt;        /// Creates a ServiceHandler appropiate for the call&lt;br&gt;        /// &amp;lt;/summary&amp;gt;&lt;br&gt;        /// &amp;lt;param name="up"&amp;gt;A UriProcessor object with the data from the call&amp;lt;/param&amp;gt;&lt;br&gt;        /// &amp;lt;returns&amp;gt;A class that implements IServiceable&amp;lt;/returns&amp;gt;&lt;br&gt;        public static IServiceable Create(UriProcessor up)&lt;br&gt;        {&lt;br&gt;            return (IServiceable)Activator.CreateInstance(Type.GetType("LaTrompa.Services." + up.ReturnFormat + "ServiceHandler"));&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&lt;!--more--&gt;&lt;/p&gt;&lt;h3&gt;Some base classes.&lt;/h3&gt;&lt;p&gt;We need to encapsulate some code, so we apply the DRY principle, that code will reside in two base classes.&lt;/p&gt;&lt;p&gt;The first class is used by our formatter classes, they need to format different type of objects so they need to call a class that knows how to process the call for that given object, get the object, modify it according to the parameters and commands and them returned to the formatter class that will format it and do the response.&lt;/p&gt;&lt;pre lang="csharp"&gt;using System;&lt;br&gt;using System.Web;&lt;br&gt;&lt;br&gt;namespace LaTrompa.Services&lt;br&gt;{&lt;br&gt;    public class FormatServiceHandler&lt;br&gt;    {&lt;br&gt;        protected object GetRequestedObject(HttpContext context) &lt;br&gt;        {&lt;br&gt;            UriProcessor up = new UriProcessor(context.Request.Url);&lt;br&gt;            IServiceRequestHandler service = (IServiceRequestHandler)Activator.CreateInstance(Type.GetType("LaTrompa.Service." + up.ObjectType + "ServiceHandler"));&lt;br&gt;            return service.GetRequestedObject(up);        &lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;The second object, is one of our objects handlers, some scheleton code at this moment. This objects implement IServiceRequestHandler.&lt;/p&gt;&lt;pre lang="csharp"&gt;using System;&lt;br&gt;using System.Collections.Specialized;&lt;br&gt;using System.Web;&lt;br&gt;using MyGeneration.dOOdads;&lt;br&gt;&lt;br&gt;namespace LaTrompa.Services&lt;br&gt;{&lt;br&gt;    public class DataServiceHandler : IServiceRequestHandler&lt;br&gt;    {&lt;br&gt;        private BusinessEntity _dataObject;&lt;br&gt;&lt;br&gt;        protected void LoadDataObject(string objectName)&lt;br&gt;        {&lt;br&gt;            this._dataObject = (BusinessEntity)Activator.CreateInstance(Type.GetType("LaTrompa.DAL." + objectName, true, true));&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        private object List(NameValueCollection qs) { return null; }&lt;br&gt;        private object Delete(NameValueCollection qs) { return null;  }&lt;br&gt;        private object Insert(NameValueCollection qs) { return null;  }&lt;br&gt;        private object Update(NameValueCollection qs) { return null;  }&lt;br&gt;        private object GetColumns() &lt;br&gt;        {&lt;br&gt;            //this._dataObject.&lt;br&gt;            return null;&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        #region IServiceRequestHandler Members&lt;br&gt;&lt;br&gt;        public object GetRequestedObject(UriProcessor up)&lt;br&gt;        {&lt;br&gt;            this.LoadDataObject(up.ObjectName);&lt;br&gt;&lt;br&gt;            switch (up.Command.ToUpper())&lt;br&gt;            {&lt;br&gt;                case "LIST":&lt;br&gt;                    this.List(up.Qs);&lt;br&gt;                    break;&lt;br&gt;                case "DELETE":&lt;br&gt;                    this.Delete(up.Qs);&lt;br&gt;                    break;&lt;br&gt;                case "UPDATE":&lt;br&gt;                    this.Update(up.Qs);&lt;br&gt;                    break;&lt;br&gt;                case "INSERT":&lt;br&gt;                    this.Insert(up.Qs);&lt;br&gt;                    break;&lt;br&gt;                case "GETCOLUMNS":&lt;br&gt;                    this.GetColumns();&lt;br&gt;                    break;&lt;br&gt;            }&lt;br&gt;            return null;&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        #endregion&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;The Formatter class&lt;/h3&gt;&lt;pre lang="csharp"&gt;using System;&lt;br&gt;using System.Web;&lt;br&gt;&lt;br&gt;namespace LaTrompa.Services&lt;br&gt;{&lt;br&gt;    public class JsonServiceHandler : FormatServiceHandler, IServiceable&lt;br&gt;    {&lt;br&gt;        public void Process(HttpContext context)&lt;br&gt;        {&lt;br&gt;            object requested = base.GetRequestedObject(context);&lt;br&gt;            //TODO: Implementation&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;</Content>
      <Created>2007-12-07T22:13:00-07:00</Created>
      <Modified>2008-12-14T22:42:18.8917109-07:00</Modified>
      <EntryId>11</EntryId>
      <Description />
      <Title>A REST API in 20 minutes - Part 2</Title>
      <Categories>Patterns;Programming</Categories>
      <Author>hgarcia</Author>
      <IsPublic>true</IsPublic>
      <Syndicated>true</Syndicated>
      <ShowOnFrontPage>true</ShowOnFrontPage>
      <AllowComments>true</AllowComments>
      <Attachments />
      <Crossposts />
      <Latitude xsi:nil="true" />
      <Longitude xsi:nil="true" />
    </Entry>
    <Entry>
      <Content>&lt;p&gt;If you haven't look at it, take a look at the &lt;a href="http://subsonicproject.com/" target="_blank"&gt;Subsonic &lt;/a&gt;project, is really cool and can generate a ORM infrastructure faster than any other framework I tried out there and it also provides a cool HTTPHandler to expose those objects.&lt;/p&gt;&lt;p&gt;The only problem is that your database have to follow some minor conventions and sometimes you need to work with legacy databases where those conventions where not follow.&lt;/p&gt;&lt;p&gt;A solution is to use the &lt;a href="http://www.mygenerationsoftware.com/portal/dOOdads/dOOdadsOverview/tabid/63/Default.aspx" target="_blank"&gt;DooDads &lt;/a&gt;architecture and &lt;a href="http://www.mygenerationsoftware.com/portal/Home/tabid/36/Default.aspx" target="_blank"&gt;My Generation&lt;/a&gt; as the code generating tool. Doodads was always open source and now My Generation is open source as well. I even modify the BussinessEntity class on the architecture to fit my needs in some projects and work around some unorthodox database architectural decisions I found.&lt;/p&gt;&lt;p&gt;Once you have your doodads objects for all the tables and views that you want to expose you need to create the HttpHandlers to expose those objects.&lt;/p&gt;&lt;p&gt;&lt;!--more--&gt;&lt;/p&gt;&lt;p&gt;This are some of the things I needed:&lt;/p&gt;&lt;ol&gt;    &lt;li&gt;Pure REST&lt;/li&gt;    &lt;li&gt;Not so pure REST&lt;/li&gt;    &lt;li&gt;Multiple response formats (ex: Json, Xml, Csv)&lt;/li&gt;    &lt;li&gt;Being able to expose new databases object in the future without coding, just generate the object and a change in the url should make the object available.&lt;/li&gt;    &lt;li&gt;The API should document itself (ex: the end user should be able to ask for available properties (columns) on a object)&lt;/li&gt;    &lt;li&gt;Being able to expose not just databases objects but other type of objects in the future.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;h2&gt;URL Format and how to read them.&lt;/h2&gt;&lt;p&gt;I wanted very easy to read urls, so I came with this scheme.&lt;/p&gt;&lt;pre&gt;http://domain/Web/ObjectType/ObjectName/command.format?params&lt;/pre&gt;&lt;p&gt;Where:&lt;/p&gt;&lt;p&gt;domain: Do I need to explain this? (ex: blog.latrompa.com)&lt;/p&gt;&lt;p&gt;web: The subfolder where your api will reside (ex: services)&lt;/p&gt;&lt;p&gt;ObjectType: The type of object to expose (ex: data)&lt;/p&gt;&lt;p&gt;ObjectName: The name of the object (ex: Article)&lt;/p&gt;&lt;p&gt;command: The command to execute on the object (this is only for non true REST, true REST use the HTTP VERB) (ex: list)&lt;/p&gt;&lt;p&gt;format: The extention inidicates the format of the response (ex: json)&lt;/p&gt;&lt;p&gt;params: The querystring with parameters to modify the response.&lt;/p&gt;&lt;p&gt;A url to request the Data for all Articles Created after October first 2007 will look like this.&lt;/p&gt;&lt;p&gt;http://blog.latrompa.com/Services/Data/Article/list.json?created_more=10/01/2007&lt;/p&gt;&lt;p&gt;Notice the parameters created is the name of a field in the Article table and the _more indicates what operand to use in the where clause.&lt;/p&gt;&lt;p&gt;It took this idea from the &lt;a target="_blank" href="http://subsonicproject.com/view/rest-linq-and-you.aspx"&gt;HttpHandler implementation on Subsonic&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;Architecture:&lt;/h2&gt;&lt;h3&gt;Interfaces.&lt;/h3&gt;&lt;pre lang="csharp"&gt;using System;&lt;br&gt;using System.Web;&lt;br&gt;&lt;br&gt;namespace LaTrompa.Services&lt;br&gt;{&lt;br&gt;    public interface IServiceable&lt;br&gt;    {&lt;br&gt;        void Process(HttpContext context);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;pre lang="csharp"&gt;using System;&lt;br&gt;&lt;br&gt;namespace LaTrompa.Services&lt;br&gt;{&lt;br&gt;    public interface IServiceRequestHandler&lt;br&gt;    {&lt;br&gt;        object GetRequestedObject(UriProcessor up);&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Utilities.&lt;/h3&gt;&lt;p&gt;I create this class to map a uri into an object for easy manipulation, the uri is what will tell us wich object to load and how to process it.&lt;/p&gt;&lt;pre lang="csharp"&gt;using System;&lt;br&gt;using System.Collections.Specialized;&lt;br&gt;using System.Web;&lt;br&gt;&lt;br&gt;namespace LaTrompa.Services&lt;br&gt;{&lt;br&gt;    public class UriProcessor&lt;br&gt;    {&lt;br&gt;        #region Properties&lt;br&gt;&lt;br&gt;        private string _web = string.Empty;&lt;br&gt;        /// &amp;lt;summary&amp;gt;&lt;br&gt;        /// Gets the Web use to call the service&lt;br&gt;        /// &amp;lt;/summary&amp;gt;&lt;br&gt;        public string Web&lt;br&gt;        {&lt;br&gt;            get { return _web; }&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        private string _protocol = string.Empty;&lt;br&gt;        /// &amp;lt;summary&amp;gt;&lt;br&gt;        /// Gets the protocol used to call the service&lt;br&gt;        /// &amp;lt;/summary&amp;gt;&lt;br&gt;        public string Protocol&lt;br&gt;        {&lt;br&gt;            get { return _protocol; }&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        private string _domain = string.Empty;&lt;br&gt;        /// &amp;lt;summary&amp;gt;&lt;br&gt;        /// Gets the domain used to call the service&lt;br&gt;        /// &amp;lt;/summary&amp;gt;&lt;br&gt;        public string Domain&lt;br&gt;        {&lt;br&gt;            get { return _domain; }&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        private string _returnFormat = string.Empty;&lt;br&gt;        /// &amp;lt;summary&amp;gt;&lt;br&gt;        /// Gets the return format for the service&lt;br&gt;        /// &amp;lt;/summary&amp;gt;&lt;br&gt;        public string ReturnFormat&lt;br&gt;        {&lt;br&gt;            get { return _returnFormat; }&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        private string _objectType = string.Empty;&lt;br&gt;        /// &amp;lt;summary&amp;gt;&lt;br&gt;        /// Gets the type of object requested&lt;br&gt;        /// &amp;lt;/summary&amp;gt;&lt;br&gt;        public string ObjectType&lt;br&gt;        {&lt;br&gt;            get { return _objectType; }&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        private string _objectName = string.Empty;&lt;br&gt;        /// &amp;lt;summary&amp;gt;&lt;br&gt;        /// Gets the name of the object requested&lt;br&gt;        /// &amp;lt;/summary&amp;gt;&lt;br&gt;        public string ObjectName&lt;br&gt;        {&lt;br&gt;            get { return _objectName; }&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        private string _command = string.Empty;&lt;br&gt;        /// &amp;lt;summary&amp;gt;&lt;br&gt;        /// Gets the command to execute on the object&lt;br&gt;        /// &amp;lt;/summary&amp;gt;&lt;br&gt;        public string Command&lt;br&gt;        {&lt;br&gt;            get { return _command; }&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        private NameValueCollection _qs = new NameValueCollection();&lt;br&gt;        /// &amp;lt;summary&amp;gt;&lt;br&gt;        /// Gets the querystring used in the call&lt;br&gt;        /// &amp;lt;/summary&amp;gt;&lt;br&gt;        public NameValueCollection Qs&lt;br&gt;        {&lt;br&gt;            get { return _qs; }&lt;br&gt;        }&lt;br&gt;        #endregion&lt;br&gt;&lt;br&gt;        /// &amp;lt;summary&amp;gt;&lt;br&gt;        /// Process a uri and returns an object to be use by the ServiceHandlerFactory&lt;br&gt;        /// &amp;lt;/summary&amp;gt;&lt;br&gt;        /// &amp;lt;param name="url"&amp;gt;The uri object from the request&amp;lt;/param&amp;gt;&lt;br&gt;        public UriProcessor(Uri url)&lt;br&gt;        {&lt;br&gt;            if (url.Segments.Length != 5)&lt;br&gt;            {&lt;br&gt;                throw new UriMalformedException();&lt;br&gt;            }&lt;br&gt;            this._web = url.Segments[1].Replace("/", "");&lt;br&gt;            this._objectType = url.Segments[2].Replace("/", "");&lt;br&gt;            this._objectName = url.Segments[3].Replace("/", "");&lt;br&gt;&lt;br&gt;            string[] com = url.Segments[4].Split('.');&lt;br&gt;            if (com.Length != 2)&lt;br&gt;            {&lt;br&gt;                throw new UriMalformedException();&lt;br&gt;            }&lt;br&gt;            this._command = com[0];&lt;br&gt;            this._returnFormat = com[1];&lt;br&gt;&lt;br&gt;            this._protocol = url.Scheme;&lt;br&gt;            this._domain = url.Host;&lt;br&gt;&lt;br&gt;            this._qs = HttpUtility.ParseQueryString(url.Query);&lt;br&gt;            &lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;Custom Exceptions&lt;/h3&gt;&lt;p&gt;We want to throw custom exceptions, don't we?&lt;/p&gt;&lt;p&gt;This is just in the works, only one class for now.&lt;/p&gt;&lt;pre lang="csharp"&gt;using System;&lt;br&gt;&lt;br&gt;namespace LaTrompa.Services&lt;br&gt;{&lt;br&gt;    public class UriMalformedException : Exception&lt;br&gt;    {&lt;br&gt;        public UriMalformedException() : base("The uri has the wrong format")&lt;br&gt;        {&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;h3&gt;The HTTP Handler&lt;/h3&gt;&lt;p&gt;We will map the extentions that we won't to handle via the API to this Http Handler.&lt;/p&gt;&lt;pre lang="csharp"&gt;using System;&lt;br&gt;using System.Web;&lt;br&gt;&lt;br&gt;namespace LaTrompa.Services&lt;br&gt;{&lt;br&gt;    public class ServiceHandler : IHttpHandler&lt;br&gt;    {&lt;br&gt;        #region IHttpHandler Members&lt;br&gt;&lt;br&gt;        public bool IsReusable&lt;br&gt;        {&lt;br&gt;            get { return false; }&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        public void ProcessRequest(HttpContext context)&lt;br&gt;        {&lt;br&gt;            UriProcessor up = new UriProcessor(context.Request.Url);&lt;br&gt;            IServiceable service = ServiceHandlerFactory.Create(up);&lt;br&gt;            service.Process(context);&lt;br&gt;        }&lt;br&gt;&lt;br&gt;        #endregion&lt;br&gt;    }&lt;br&gt;}&lt;/pre&gt;&lt;p&gt;&amp;nbsp;You may notice that the HttpHandler doesn't handler the call but it use a Factory to create an object that implements IServiceable that will understand how to handle the call.&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;</Content>
      <Created>2007-12-07T21:34:32-07:00</Created>
      <Modified>2008-12-14T22:35:43.393295-07:00</Modified>
      <EntryId>10</EntryId>
      <Description />
      <Title>A REST API in 20 minutes - Part 1</Title>
      <Categories>Patterns;Programming</Categories>
      <Author>hgarcia</Author>
      <IsPublic>true</IsPublic>
      <Syndicated>true</Syndicated>
      <ShowOnFrontPage>true</ShowOnFrontPage>
      <AllowComments>true</AllowComments>
      <Attachments />
      <Crossposts />
      <Latitude xsi:nil="true" />
      <Longitude xsi:nil="true" />
    </Entry>
    <Entry>
      <Content>&lt;p&gt;Yesterday Scott Gu post again about the MVC framework. Don't miss his post about&lt;a href="http://weblogs.asp.net/scottgu/archive/2007/12/06/asp-net-mvc-framework-part-3-passing-viewdata-from-controllers-to-views.aspx" target="_blank"&gt; Passing View data from controllers to view.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;There was some talk about the release date being this week, but that wont be the case. I think that is just fair to tell that we are all waiting for it. I just want to get my hands on the code, and have an old asp classic site that can be a great candidate to migrate using the framework.&lt;/p&gt;</Content>
      <Created>2007-12-07T21:06:37-07:00</Created>
      <Modified>2008-12-14T22:27:08.3607833-07:00</Modified>
      <EntryId>9</EntryId>
      <Description />
      <Title>Microsoft MVC coming along.</Title>
      <Categories>Frameworks;Patterns;Programming</Categories>
      <Author>hgarcia</Author>
      <IsPublic>true</IsPublic>
      <Syndicated>true</Syndicated>
      <ShowOnFrontPage>true</ShowOnFrontPage>
      <AllowComments>true</AllowComments>
      <Attachments />
      <Crossposts />
      <Latitude xsi:nil="true" />
      <Longitude xsi:nil="true" />
    </Entry>
    <Entry>
      <Content>&lt;p&gt;I am an entusiast of Test Driven Development but sometimes I have the problem that is difficult to know how to start testing. The problem usually is, very ambiguous requirements provided by the client. I know that we all have sometimes this problem and this is not an issue related to TDD, this is an issue related to pretty much any development practice.&lt;/p&gt;&lt;p&gt;Here is when &lt;a target="_blank" href="http://behaviour-driven.org/"&gt;BDD &lt;/a&gt;comes to the rescue. I read this &lt;a target="_blank" href="http://dannorth.net/whats-in-a-story"&gt;article &lt;/a&gt;from Dan North's blog and everything makes sense.&lt;/p&gt;&lt;p&gt;I have started to play around with nBehave and so far I like it, now I will love to have a pure english editor or some kind of wizard for my clients to be able to define requirements easily.&lt;/p&gt;</Content>
      <Created>2007-12-07T21:00:39-07:00</Created>
      <Modified>2008-12-14T22:10:03.3192497-07:00</Modified>
      <EntryId>8</EntryId>
      <Description />
      <Title>Applying BDD to requirements gathering.</Title>
      <Categories>Methodology;Testing</Categories>
      <Author>hgarcia</Author>
      <IsPublic>true</IsPublic>
      <Syndicated>true</Syndicated>
      <ShowOnFrontPage>true</ShowOnFrontPage>
      <AllowComments>true</AllowComments>
      <Attachments />
      <Crossposts />
      <Latitude xsi:nil="true" />
      <Longitude xsi:nil="true" />
    </Entry>
  </Entries>
</DayEntry>