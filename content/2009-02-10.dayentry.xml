<?xml version="1.0" encoding="utf-8"?>
<DayEntry xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="urn:newtelligence-com:dasblog:runtime:data">
  <Date>2009-02-09T17:00:00-07:00</Date>
  <Entries>
    <Entry>
      <Content>&lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;I try to practice TDD most of the time these days. I don’t write new code without a test first. A few years ago write the test first was something that I understood from an intellectual point of view but it sounded impractical. Today I can imagine going back to my old practices.&lt;/p&gt; &lt;p&gt;So, now I’m one of those advocates that try to convert other developers to the practice. I try to draw from my experience and I try to address their concerns as a challenge to discover new practices and improve mines.&lt;/p&gt; &lt;p&gt;Recently I came across this challenge. How you can write your test first when you are learning a new API of a library? If you practice TDD you will said something like, but that s the perfect scenario to use TDD! Now, that’s true but is not immediately evident to a developer that is just starting on the practice.&lt;/p&gt; &lt;p&gt;What we need to understand is that sometimes we can use the test as a learning tool. We also need to understand that we will refactor the test code. We can even use code that we originally used in our test and move that into our implementation.&lt;/p&gt; &lt;p&gt;Today I had the perfect example: we needed to convert a string into a DateTime object, the string is in the following format: 2009-01-07-23-15-09. &lt;/p&gt; &lt;p&gt;Our first implementation looked something like this:&lt;/p&gt;&lt;pre class="c#:collapse" name="code"&gt;//The unit test&lt;br&gt;[Test]&lt;br&gt;public void Check_that_when_converting_a_string_time_we_have_the_right_date()&lt;br&gt;}&lt;br&gt;    &lt;br&gt;&lt;br&gt;    var controlDate = new DateTime(2009,01,07,23,15,09);&lt;br&gt;    var date = GetDateFromString("2009-01-07-23-15-09");&lt;br&gt;&lt;br&gt;    Assert.That(controlDate, Is.EqualTo(date));&lt;br&gt;}&lt;br&gt;&lt;br&gt;//And the implementation&lt;br&gt;public DateTime GetDateFromString(string date){&lt;/pre&gt;&lt;pre class="c#:collapse" name="code"&gt;    var date = "2009-01-07-23-15-09".Split('-');&lt;br&gt;&lt;br&gt;    return new DateTime(Convert.ToInt(dateParts[0]),&lt;br&gt;                        Convert.ToInt(dateParts[1]),&lt;br&gt;                        Convert.ToInt(dateParts[2]),&lt;br&gt;                        Convert.ToInt(dateParts[3]),&lt;br&gt;                        Convert.ToInt(dateParts[4]),&lt;br&gt;                        Convert.ToInt(dateParts[5]));&lt;br&gt;&lt;br&gt;}&lt;/pre&gt;
&lt;p&gt;This worked but was messy, and besides adding some more test will make it fail easily. For example passing a malformed string. In those cases we wanted to have an exception raised that was meaningful. We imagine that we should be able to use DateTime.ParseExact() but we didn’t really know how it worked. O we changed our test like this.&lt;/p&gt;&lt;pre class="c#:collapse" name="code"&gt;//The unit test&lt;br&gt;[Test]&lt;br&gt;public void Check_that_when_converting_a_string_time_we_have_the_right_date()&lt;br&gt;}&lt;br&gt;    //Some code to get the cultureinfo&lt;br&gt;&lt;br&gt;    var controlDate = new DateTime(2009,01,07,23,15,09);&lt;br&gt;    var date = DateTime.ParseExact("2009-01-07-23-15-09",”yyyy-MM-dd-hh-mm-ss”,culture);&lt;br&gt;&lt;br&gt;    Assert.That(controlDate, Is.EqualTo(date));&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;
&lt;p&gt;And the test to check for the exception&lt;/p&gt;&lt;pre class="c#:collapse" name="code"&gt;//The unit test&lt;br&gt;[Test]&lt;br&gt;[ExpectedException(typeof(exceptionType)]&lt;br&gt;public void Check_that_when_converting_a_string_time_we_have_the_right_date()&lt;br&gt;}&lt;br&gt;    //Some code to get the cultureinfo&lt;br&gt;&lt;br&gt;    var date = DateTime.ParseExact("29-01-07-23-15-09",”yyyy-MM-dd-hh-mm-ss”,culture);&lt;br&gt;&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;
&lt;p&gt;We run the test and we see it pass, so them we just copy and paste the code into the implementation of the client function and we change the test back.&lt;/p&gt;&lt;pre class="c#:collapse" name="code"&gt;//The unit test&lt;br&gt;[Test]&lt;br&gt;public void Check_that_when_converting_a_string_time_we_have_the_right_date()&lt;br&gt;}&lt;br&gt;    &lt;br&gt;&lt;br&gt;    var controlDate = new DateTime(2009,01,07,23,15,09);&lt;br&gt;    var date = GetDateFromString("2009-01-07-23-15-09");&lt;br&gt;&lt;br&gt;    Assert.That(controlDate, Is.EqualTo(date));&lt;br&gt;}&lt;/pre&gt;&lt;pre class="c#:collapse" name="code"&gt;//And the test for the Exception&lt;/pre&gt;&lt;pre class="c#:collapse" name="code"&gt;//The unit test&lt;br&gt;[Test]&lt;br&gt;[ExpectedException(typeof(exceptionType)]&lt;br&gt;public void Check_that_when_converting_a_string_time_we_have_the_right_date()&lt;br&gt;}&lt;br&gt;&lt;br&gt;&lt;br&gt;    var date = GetDateFromString("29-01-07-23-15-09”);&lt;br&gt;&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;pre class="c#:collapse" name="code"&gt;&lt;br&gt;&lt;br&gt;//And the implementation&lt;br&gt;public DateTime GetDateFromString(string date){&lt;/pre&gt;
&lt;blockquote&gt;&lt;pre class="c#:collapse" name="code"&gt;//Some code to get the cultureinfo&lt;br&gt;return DateTime.ParseExact("2009-01-07-23-15-09",”yyyy-MM-dd-hh-mm-ss”,culture);&lt;/pre&gt;&lt;/blockquote&gt;}&lt;pre&gt;&lt;/pre&gt;
&lt;p&gt;This is a trivial example and you may think that we probably should change the code in the implementation right away, and that may be ok in this case, but using this practice all the time make it natural later on when you have to deal with a more complex API, like using some third party component.&lt;/p&gt;
&lt;p&gt;In a future post I will show how to use tests as a debugging tool that will help you to fix problems and ensure they don’t show up again.&lt;/p&gt;</Content>
      <Created>2009-02-10T05:14:00-07:00</Created>
      <Modified>2009-02-09T22:16:06.7570328-07:00</Modified>
      <EntryId>5e552373-b52d-4089-850b-50dbfd65aef0</EntryId>
      <Description />
      <Title>Using tests as a learning tool</Title>
      <Categories>Methodology;Programming;Testing</Categories>
      <Author>hgarcia</Author>
      <IsPublic>true</IsPublic>
      <Syndicated>true</Syndicated>
      <ShowOnFrontPage>true</ShowOnFrontPage>
      <AllowComments>true</AllowComments>
      <Attachments />
      <Crossposts />
      <Latitude xsi:nil="true" />
      <Longitude xsi:nil="true" />
    </Entry>
    <Entry>
      <Content>&lt;p&gt;   &lt;br /&gt;In a recent post I talked about &lt;a href="http://blog.dynamicprogrammer.com/2009/01/15/IsolateYourselfFromExternalLibrariesUsingTheFacadePattern.aspx" target="_blank"&gt;isolating your code from third party libraries using the facade pattern&lt;/a&gt;. In the post I wrote about wrapping log4net (as an example) in your own logging class and define an interface for the log object that better reflects your domain. &lt;/p&gt;  &lt;p&gt;The main benefit of doing this is that your client code (the one that needs a logger) won’t have a dependency on an interface defined by an external library, given you the desired flexibility to change the library that implements the logger later on. All your client code will keep using your abstraction.&lt;/p&gt;  &lt;p&gt;But what happens if the external library defines it’s own exceptions? What if one of this exceptions may be thrown during usage and you want to catch it and do something to fix the problem? &lt;/p&gt;  &lt;p&gt;Let’s assume the 3rd party library is an html parser library that contains the following classes:&lt;/p&gt;  &lt;pre class="c#:collapse" name="code"&gt;ThirdParty.HtmlParser.HtmlElement&lt;br /&gt;ThirdParty.HtmlParser.Parser&lt;br /&gt;ThirdParty.HtmlParser.HtmlElements : IEnumerable&amp;lt;HtmlElement&amp;gt;&lt;br /&gt;ThirdParty.HtmlParser.MalFormedHtmlException : Exception&lt;/pre&gt;

&lt;p&gt;Notice the MalFormedHtmlException class, this is an exception that this library may throw. At this point just wrapping the library alone won’t help you. What you need to do is catch the exception in the wrapper library and raise you own exceptions. 
  &lt;br /&gt;This exceptions may have the same meaning but for sure the name will more closely reflects your domain.&lt;/p&gt;

&lt;p&gt;Let’s create a simple wrapper that returns all images url’s in an HtmlDocument given an id:&lt;/p&gt;

&lt;pre class="c#:collapse" name="code"&gt;public class HtmlParser{&lt;br /&gt;&lt;br /&gt;    public HtmlParser(Uri url){&lt;br /&gt;        //...&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    public IEnumerable&amp;lt;string&amp;gt; GetImagesUrls(){&lt;br /&gt;        //...&lt;br /&gt;    }&lt;br /&gt;    &lt;br /&gt;&lt;br /&gt;}&lt;/pre&gt;

&lt;p&gt;Now the problem is that GetImagesUrls needs to parse the document and at that moment the MalFormedHtmlException. Knowing this your client code will have to do something like this to protect the application from crashing.&lt;/p&gt;

&lt;pre class="c#:collapse" name="code"&gt;public class ParserUI{&lt;br /&gt;&lt;br /&gt;    public void ShowImages(){&lt;br /&gt;&lt;br /&gt;        //Some code&lt;br /&gt;        try{&lt;br /&gt;            parser.GetImagesUrls();&lt;br /&gt;        }catch(MalFormedHtmlException){&lt;br /&gt;            testLabel.Text = &amp;quot;Oops, the html document is not valid and can't be parsed.&amp;quot;&lt;br /&gt;        }catch(Exception e){&lt;br /&gt;        //More code&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;}&lt;/pre&gt;

&lt;p&gt;A this moment our UI holds a reference to the original library to brake that dependency. 
  &lt;br /&gt;We need to modify the code for the wrapper and provide our own exception.&lt;/p&gt;

&lt;pre class="c#:collapse" name="code"&gt;public class HtmlParser{    &lt;br /&gt;    public HtmlParser(Uri url)&lt;br /&gt;    {        &lt;br /&gt;        //...    &lt;br /&gt;    }    &lt;br /&gt;    public IEnumerable&amp;lt;string&amp;gt; GetImagesUrls()&lt;br /&gt;    {        &lt;br /&gt;        try{&lt;br /&gt;        }catch(MalFormedHtmlException){&lt;br /&gt;            throw new HtmlMalFormedException()&lt;br /&gt;        }catch(Exception)&lt;br /&gt;          //....&lt;br /&gt;    }    &lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;public class HtmlMalFormedException :  Exception&lt;br /&gt;{&lt;br /&gt;&lt;br /&gt;    public HtmlMalFormedException() : base(@&amp;quot;The html for the document is not well formed html. &lt;br /&gt;                              Please use a tool like the w3c Validator to verify the document&amp;quot;){}&lt;br /&gt;&lt;br /&gt;}&lt;/pre&gt;

&lt;p&gt;Now the client can be change as well&lt;/p&gt;

&lt;pre class="c#:collapse" name="code"&gt;public class ParserUI{&lt;br /&gt;&lt;br /&gt;    public void ShowImages(){&lt;br /&gt;&lt;br /&gt;        //Some code&lt;br /&gt;        try{&lt;br /&gt;            parser.GetImagesUrls();&lt;br /&gt;        }catch(HtmlMalFormedException htmlMalFormed){&lt;br /&gt;            testLabel.Text = htmlMalFormed.Mesage&lt;br /&gt;        }catch(Exception e){&lt;br /&gt;        //More code&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;}&lt;/pre&gt;

&lt;p&gt;Notice how you just removed any dependency to the original library, but you can also use the message from the exception to display to the end user. Since you know your domain, the message can be tailored in a way that explain what just happened and even provide alternative solutions on how to fix the problem.&lt;/p&gt;

&lt;p&gt;Next time we will talk about attributes.&lt;/p&gt;</Content>
      <Created>2009-02-09T21:00:12.2770895-07:00</Created>
      <Modified>2009-02-10T20:38:36.5664929-07:00</Modified>
      <EntryId>725599d2-1b6a-4c57-a0f7-f6ea11a393ee</EntryId>
      <Description />
      <Title>The problem with third party libraries; Exceptions.</Title>
      <Categories>Patterns;Programming</Categories>
      <Author>hgarcia</Author>
      <IsPublic>true</IsPublic>
      <Syndicated>true</Syndicated>
      <ShowOnFrontPage>true</ShowOnFrontPage>
      <AllowComments>true</AllowComments>
      <Attachments />
      <Crossposts />
      <Latitude xsi:nil="true" />
      <Longitude xsi:nil="true" />
    </Entry>
  </Entries>
</DayEntry>