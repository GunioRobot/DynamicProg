---
layout: post
title: How Linq works, lamdbas, anonymous delegates and some compiler voodoo.
summary: If you have been following this blog, you probably saw a few posts about what’s going on behind closed doors once you submit your code to the mercy of the compiler.
categories: [Programming, .Net]
---

If you have been following this blog, you probably saw a few posts about what’s going on behind closed doors once you submit your code to the mercy of the compiler. Specially some of the new Magic features of C#, like auto properties and nullable types.

The next logical step is to take a pick to how Linq works (or more specifically some of the implementation).

Let’s take a look at something very simple. A function that filters a list of strings by the initial character.

{% highlight aspx-cs %}
	namespace CodeBehind
	{
		public class LookBehindLinq
		{
			public IList<string> UsernamesByStartingChar(IList<string> userNames, char startingChar)
			{
				return userNames.Where(item => item.ToLower()
				.StartsWith(startingChar.ToString())).ToList();
			}
		}
	}
{% endhighlight %}    

We are using the extension method Where and we pass a lambda expression that reads something like, get each item, making it lowercase and check if starts with this character, if so put it in a new enumeration. Them we use another extension method to convert the enumeration to a List.

Let’s compile this and see what Reflector have to tell us about it. Let’s look at the code as C#:

{% highlight aspx-cs %}	
	public class LookBehindLinq
	{
		// Methods
		public IList<string> UsernamesByStartingChar(IList<string> userNames, char startingChar)
		{
			return userNames.Where<string>(delegate(string item)
				{
					return item.ToLower().StartsWith(startingChar.ToString());
				}).ToList<string>();
		}
	}
{% endhighlight %}

That looks very similar to the original code, the lambda notation have been replaced by an anonymous delegate but the rest of the code looks the same. But wait take a look at the object tree for this class.

<a href="../../../images/posts/HowLinqworkslamdbasanonymousdelegatesan_88A/ScreenHunter_16%202009-03-09%2000.11.23_2.jpg"><img height="185" alt="ScreenHunter_16 2009-03-09 00.11.23" src="../../../images/posts/HowLinqworkslamdbasanonymousdelegatesan_88A/ScreenHunter_16%202009-03-09%2000.11.23_thumb.jpg" width="395" border="0" /></a> 

Do you see that <>c_DisplayClass1 private sealed subclass inside our original class?

Let’s take a look at the code.

{% highlight aspx-cs %}
[CompilerGenerated]
	private sealed class <>c__DisplayClass1
	{
		// Fields
		public char startingChar;
	
		// Methods
		public bool <UsernamesByStartingChar>b__0(string item)
		{
			return item.ToLower().StartsWith(this.startingChar.ToString());
		}
	}
{% endhighlight %}

This class has only one method that looks like our delegate. That makes sense but how the Where works? It calls this delegate that returns true or false, and them what?
Let’s click in the Where method in Reflector and take a deeper look.

{% highlight aspx-cs %}
	public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
	{
		if (source == null)
		{
			throw Error.ArgumentNull("source");
		}
		
		if (predicate == null)
		{
			throw Error.ArgumentNull("predicate");
		}
		
		if (source is Iterator<TSource>)
		{
			return ((Iterator<TSource>) source).Where(predicate);
		}
		
		if (source is TSource[])
		{
			return new WhereArrayIterator<TSource>((TSource[]) source, predicate);
		}
		
		if (source is List<TSource>)
		{
			return new WhereListIterator<TSource>((List<TSource>) source, predicate);
		}
		
		return new WhereEnumerableIterator<TSource>(source, predicate);

	}
{% endhighlight %}
  
Since we are passing a List I guess we should take a look at the WhereListIterator object. This is a private class inside the Enumerable object.

{% highlight aspx-cs %}
	private class WhereListIterator<TSource> : Enumerable.Iterator<TSource>
	{
		// Fields
		private List<TSource>.Enumerator enumerator;
		private Func<TSource, bool> predicate;
		private List<TSource> source;
		
		// Methods
		public WhereListIterator(List<TSource> source, Func<TSource, bool> predicate);
		public override Enumerable.Iterator<TSource> Clone();
		public override bool MoveNext();
		public override IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector);
		public override IEnumerable<TSource> Where(Func<TSource, bool> predicate);
	}
{% endhighlight %}
 
Now, we "know" that all the Linq magic happens when the code is actually run (<a href="http://www.hookedonlinq.com/DeferredExecution.ashx" target="_blank">deferred execution</a>) so the bits that we are interest in should be on the MoveNext method:

{% highlight aspx-cs %}
	public override bool MoveNext()
	{
		switch (base.state)
		{
			case 1:
				this.enumerator = this.source.GetEnumerator();
				base.state = 2;
				break;
			case 2:
				break;
			default:
				goto Label_0069;
		}
		
		while (this.enumerator.MoveNext())
		{
			TSource current = this.enumerator.Current;
			if (this.predicate(current))
			{
				base.current = current;
				return true;
			}
		}

		this.Dispose();
		Label_0069:
		return false;
	}
{% endhighlight %}

I’m not sure why we have a Label_0069 in there and the goto in the switch statement, that sounds fishy, but again I don’t really know all the scenarios for this code.
The filtering happens in the while loop.

It takes the current item of the enumeration, pass the item to the delegate and if the result is true it add the item back to the base. It does this each time is called.
I guess my next one may be the Select method, any suggestion?