---
layout: post
title: MongoDb provider for BlogEngine.net, part 3 â€" Mappers and more refactoring.
summary: In the previous post on this series we manage to get our Insert and a basic Select methods working. Today we need to implement the mapper class for Post.
categories: [MongoDB, Programming]
---

In the previous post on this series we manage to get our Insert and a basic Select methods working. Today we need to implement the mapper class for Post. But first letâ€™s check what we have done so far and see if we can improve this a bit. We notice some duplication on the MongoDb class.

This code is triplicate.

{% highlight aspx-cs %}
	public void Insert<TEntity>(TEntity entity)
	{
	    var document = _mongoMapperFactory.GetMapper<TEntity>().Map(entity);
	    Db(db=> db.GetCollection(entity.GetType().Name+"Docs").Insert(document));
	}
	
	public TEntity SelectOne<TEntity>(string id)
	{
	    Document document;
	    using (var server = GetServer())
	    {
	        document = server.getDB(_dbName)
	            .GetCollection(typeof (TEntity).Name + "Docs")
	            .AsQueryable()
	            .First(doc => doc["Id"].ToString().Contains(id));
	        var mapper = _mongoMapperFactory.GetMapper<TEntity>();
	        return mapper.Map(document);
	    }
	} 
	
	public IQueryable GetQueryableFOr<TEntity>()
	{
	    return GetServer().getDB(_dbName)
	        .GetCollection(typeof (TEntity).Name + "Docs")
	        .AsQueryable();
	}
{% endhighlight %}

First we modify the semantics in the first routine to make it identical to the other two. Them we do Extract method on it and replace all the instances with a call to this new method.

{% highlight aspx-cs %}
	public static string GetCollectionNameFor<TEntity>()
	{
	    return typeof (TEntity).Name + "Docs";
	}
{% endhighlight %}

Now that our code is better, letâ€™s create the first mapper.

{% highlight aspx-cs %}
	public Post Map(Document document)
	{
		var post = new Post
		{
			Id = new Guid(document["Id"].ToString()),
			Author = document["Author"].ToString(),
			Title = document["Title"].ToString(),
			Description = document["Description"].ToString(),
			Content = document["Content"].ToString(),
			DateCreated = DateTime.Parse(document["Raters"].ToString(), CultureInfo.InvariantCulture),
			DateModified =
			DateTime.Parse(document["Raters"].ToString(), CultureInfo.InvariantCulture),
			IsPublished = bool.Parse(document["Raters"].ToString()),
			IsCommentsEnabled = bool.Parse(document["Raters"].ToString()),
			Raters = int.Parse(document["Raters"].ToString(), CultureInfo.InvariantCulture),
			Rating = float.Parse(document["Rating"].ToString(), CultureInfo.GetCultureInfo("en-gb")),
			Slug = document["Slug"].ToString()
		};
		return post;
	}
{% endhighlight %}

Thatâ€™s an ugly piece of code. And the worst thing is that we still have a lot of work ahead of us to finish this mapper. We havenâ€™t dealt with any of the collections in the Post, for example the Comments, or the Tags. We didnâ€™t write any error handling either, this will grow ugly fast. 

A better way to deal with it will be to start leveraging conventions and mappers to deal with it as automatically as possible.

h3. Conclusion.

As you can see using MongoDb in an existing application is possible. I purposely didnâ€™t touch the code of the application what could have made some of this changes easier. 

NoRM is looking very good and if you are starting from scratch I will use that driver that provides serialization and deserialization out of the box.

Today I saw that MongoHQ release a free version of their hosted solution and paying accounts start for as little as $5/month.

Go ahead and give Mongo a try. You will be happy.